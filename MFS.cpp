#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <stdint.h>
#include <string.h>
#include <inttypes.h>
#include <string>

#ifdef __cplusplus
extern "C" {
#endif

    #include <sodium.h>
    #define SODIUM_STATIC

#ifdef __cplusplus
}
#endif

#include <ctime>
#include "MFS.h"


#pragma comment(lib,"ws2_32")
#pragma comment(lib,"libsodium")

char DriveLetter[MAX_PATH];
DWORD dwRes = GetEnvironmentVariableA("HOMEDRIVE", DriveLetter, MAX_PATH);
HANDLE hMutex = CreateMutexA(NULL,FALSE,"HackMutex");

/**
* @brief time format - day week(num) Month Year Hour:Minute:Second(0-59) Meridian (AM or PM)
* @param {char*}    buffer - character buffer where date string would be stored
* @param {uint64_t} len    - Buffer length in bytes
*/
void StrDate(char* buff,uint64_t len)
{
    time_t now = time(NULL);
    struct tm* t = localtime(&now);
    strftime(buff, len, "%d %W %M %Y %H:%M:%S %p", t);
}


namespace Crypto
{
    class CryptPubKey
    {
    private:
        byte public_key[crypto_box_PUBLICKEYBYTES] = { 0 };
        byte secret_key[crypto_box_SECRETKEYBYTES] = { 0 };
        SOCKET* sock = nullptr;
    public:
        byte recv_public_key[crypto_box_PUBLICKEYBYTES] = { 0 };
        byte nonce[crypto_box_NONCEBYTES] = { 0 };
        byte* cipher_text = nullptr;
        byte* plain_text = nullptr;
        size_t clen = 0;
        CryptPubKey(SOCKET* s)
        {
            this->sock = s;
            Control ctrl;
            crypto_box_keypair(this->public_key, this->secret_key);
            ctrl.ControlCode = CODE_MY_PUBLIC_KEY;
            memcpy(ctrl.payload, this->public_key, crypto_box_PUBLICKEYBYTES);
            send(*s, (char*)&ctrl, sizeof(Control), 0);
            recv(*s, (char*)&ctrl, sizeof(Control), 0);
            if (ctrl.ResponseCode == CODE_SUCCESS)
            {
                ZeroMemory(&ctrl, sizeof(Control));
                recv(*s, (char*)&ctrl, sizeof(Control), 0);
                if (ctrl.ResponseCode == CODE_SUCCESS && ctrl.ControlCode == CODE_MY_PUBLIC_KEY)
                    memcpy(this->recv_public_key, ctrl.payload, crypto_box_PUBLICKEYBYTES);
            }
        }

        BOOL encrypt(byte* message, size_t mlen, byte* recv_public_key)
        {
            static size_t cipherlen = mlen + crypto_box_MACBYTES;
            this->cipher_text = new byte[cipherlen];
            randombytes_buf(this->nonce, sizeof(nonce));
            this->plain_text = message;
            if (crypto_box_easy(this->cipher_text, this->plain_text, mlen, this->nonce, recv_public_key, this->secret_key) != 0)
            {
                return FALSE;
            }
            this->clen = cipherlen;
            return TRUE;
        }

        BOOL decrypt(byte* ciphertext, size_t clen, byte* nonce, byte* recv_public_key)
        {
            if (crypto_box_open_easy(this->plain_text, ciphertext, clen, nonce, recv_public_key, this->secret_key) != 0)
            {
                return FALSE;
            }
            return TRUE;
        }

    };


    class CryptSymKey
    {
    private:
        byte* key = nullptr;
    public:
        byte nonce[crypto_secretbox_NONCEBYTES];
        CryptSymKey(byte* key)
        {
            this->key = key;
        }

        byte* encrypt(byte* message, size_t mlen)
        {
            size_t clen = mlen + crypto_secretbox_MACBYTES;
            randombytes_buf(nonce, crypto_secretbox_NONCEBYTES);
            memcpy(this->nonce, nonce, crypto_secretbox_NONCEBYTES);
            byte* ciphertext = new byte[clen];
            if (crypto_secretbox_easy(ciphertext, message, mlen, nonce, key) != 0)
                return nullptr;

            return ciphertext;
        }

        byte* decrypt(byte* ciphertext, size_t clen, byte* nonce)
        {
            size_t mlen = clen - crypto_secretbox_MACBYTES;
            byte* message = new byte[mlen];

            if (crypto_secretbox_open_easy(message, ciphertext, clen, nonce, this->key) != 0)
                return nullptr;
            return message;
        }

        virtual ~CryptSymKey() {};
    };

    byte* GetSessionKey(SOCKET* s)
    {
        CryptPubKey cpk{ s };
        Control ctrl;
        ctrl.ControlCode = CODE_GET_SESSION_KEY;
        cpk.encrypt((byte*)&ctrl, sizeof(Control), cpk.recv_public_key);
        send(*s, (char*)cpk.cipher_text, cpk.clen, 0);
        recv(*s, (char*)cpk.cipher_text, cpk.clen, 0);
        cpk.decrypt(cpk.cipher_text, cpk.clen, cpk.nonce, cpk.recv_public_key);
        return cpk.plain_text;
    };

}

SuperBlock sb;


void ReserveSpace(LONG spaceLow, LONG spaceHigh, HANDLE hFile)
{
    DWORD err = ::SetFilePointer(hFile, spaceLow, &spaceHigh, FILE_BEGIN);

    if (err == INVALID_SET_FILE_POINTER) {
        err = GetLastError();
        // handle error
    }
    if (!::SetEndOfFile(hFile)) {
        err = GetLastError();
        // handle error
    }
    err = ::SetFilePointer(hFile, 0, 0, FILE_BEGIN); // reset
}

//Creating virtual disk
BOOL CreateDisk(SuperBlock *sb,std::string disk_name,uint8_t disk_size = 0)
{
    //Determine Size of disk to be allocated. Maximum is 16 Gigabytes
    DWORD size = (disk_size == 0) ? DEFAULT_DISK_SIZE : (disk_size%17) * 1024 * ONE_MEGABYTE;
    //Initialize information in superblock
    sb->uDiskSize = size;
    sb->uLookup_curr_size = 0;
    sb->uLookup_offset = sizeof(SuperBlock);
    sb->uSuperBlockSize = sizeof(SuperBlock);
    //Open handle to disk file
    HANDLE hFile = CreateFileA(disk_name.c_str(),GENERIC_WRITE,0,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
    // Check for errors
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;
    //Reserve size bytes of space in disk file
    ReserveSpace(size,0, hFile);
    //Write SuperBlock to beginning of virtual disk
    WriteFile(hFile, sb, sizeof(SuperBlock), &size, NULL);
    CloseHandle(hFile);
    return TRUE;
}

//Get file header. Contains information about file contents
BOOL GetHeader(FileHeader* f,char* disk_name,SuperBlock *s,char* filename)
{
    FILE* fp;
    errno_t err = fopen_s(&fp,disk_name,"rb");
    if (err)
        return FALSE;
    fseek(fp, s->uLookup_offset, SEEK_SET);
    FileHeader *hdr = new FileHeader[s->uLookup_curr_size];
    fread(hdr, sizeof(FileHeader), s->uLookup_curr_size, fp);
    for (size_t i = 0; i < s->uLookup_curr_size; i++)
    {
        FileHeader* h = (hdr + i);
        if (strstr(h->name,filename))
        {
            memcpy(f, h, sizeof(FileHeader));
            delete[] hdr;
            fclose(fp);
            return TRUE;
        }
    }
    fclose(fp);
    return FALSE;
}

//Update the File header information
BOOL UpdateHeader(FileHeader* nf,char* disk_name,SuperBlock *s)
{
    FILE* fp;
    errno_t err = fopen_s(&fp,disk_name,"rb");
    if (err)
        return FALSE;
    fseek(fp, s->uLookup_offset, SEEK_SET);
    FileHeader* hdr = new FileHeader[s->uLookup_curr_size];
    fread(hdr, sizeof(FileHeader), s->uLookup_curr_size, fp);
    fclose(fp);

    errno_t err = fopen_s(&fp, disk_name, "ab");
    if (err)
    {
        delete[] hdr;
        return FALSE;
    }
    fseek(fp, s->uLookup_offset, SEEK_SET);
    for (size_t i = 0; i < s->uLookup_curr_size; i++)
    {
        FileHeader* h = (hdr + i);
        if (strstr(h->name,nf->name))
        {
            fwrite(nf,s->uLookup_offset + (i*sizeof(FileHeader)), 1, fp);
            fclose(fp);
            delete[] hdr;
            return TRUE;
        }
    }
    return FALSE;
}

//Create a header and update superblock with header info.
BOOL CreateHeader(char* disk_name,SuperBlock *s)
{
    if (s->uLookup_curr_size <= MAX_LOOKUP_SIZE)
    {
        FILE* fp;
        FileHeader f;
        errno_t err = fopen_s(&fp, disk_name, "ab");
        if (err)
            return FALSE;
        size_t offset_to_new_hdr = s->uLookup_offset + s->uLookup_curr_size * sizeof(FileHeader);
        fseek(fp, offset_to_new_hdr, SEEK_SET);
        fwrite(&f, sizeof(FileHeader), 1, fp);
        fclose(fp);
        UpdateSuperBlock(s, disk_name);
        return TRUE;
    }
    return FALSE;
}

//Compute checksum of given data
////uint64_t ComputeChkSum(char* data,size_t len)
////{
////    uint64_t chksum = 0;
////    for (size_t i = 0; i < len; i++)
////    {
////        chksum += (uint64_t)data[i];
////    }
////    return chksum;
////}

uint32_t crc32(uint32_t crc, const char* buf, size_t len)
{
    static uint32_t table[256];
    static int have_table = 0;
    uint32_t rem;
    uint8_t octet;
    int i, j;
    const char* p, * q;

    /* This check is not thread safe; there is no mutex. */
    if (have_table == 0) {
        /* Calculate CRC table. */
        for (i = 0; i < 256; i++) {
            rem = i;  /* remainder from polynomial division */
            for (j = 0; j < 8; j++) {
                if (rem & 1) {
                    rem >>= 1;
                    rem ^= 0xedb88320;
                }
                else
                    rem >>= 1;
            }
            table[i] = rem;
        }
        have_table = 1;
    }

    crc = ~crc;
    q = buf + len;
    for (p = buf; p < q; p++) {
        octet = *p;  /* Cast to unsigned octet. */
        crc = (crc >> 8) ^ table[(crc & 0xff) ^ octet];
    }
    return ~crc;
}

BOOL UpdateSuperBlock(SuperBlock *s, char* disk_name)
{
    FILE* fp;
    errno_t err = fopen_s(&fp, disk_name, "ab");
    if (err)
        return FALSE;
    fseek(fp, 0, SEEK_SET);
    fwrite(s, sizeof(SuperBlock), 1, fp);
    fclose(fp);
}

BOOL AllocBlock(SuperBlock *s,FileHeader* f,char* disk_name)
{
    for (int i = 0; i < MAX_STORAGE_BLOCKS; i++)
    {
        if (s->blocks[i].is_free)
        {
            f->owned_blocks[f->block_count + 1] = i;
            s->blocks[i].is_free = FALSE;

            UpdateHeader(f, disk_name, s);
        }
    }
}

size_t WriteData(char* disk_name,Block *b,char* data,size_t len)
{
    FILE* fp;
    errno_t err = fopen_s(&fp, disk_name, "ab");
    if (err)
        return -1;
    fseek(fp, b->offset, SEEK_SET);
    size_t written = fwrite(data, 1, len, fp);
    fclose(fp);
    return written;
}

void WriteBlock(char* disk_name,SuperBlock *s, size_t block_index,char* chunck,size_t len)
{
    Block block = s->blocks[block_index];
    block.chksum = crc32(0,chunck,len);
    block.is_free = FALSE;
    block.is_full = (len == MAX_BLOCK_SIZE) ? TRUE : FALSE;
    block.size_occupied = (len < MAX_BLOCK_SIZE) ? len : MAX_BLOCK_SIZE;
    block.offset = s->uBlock_offset + (block_index * MAX_BLOCK_SIZE);
    s->blocks[block_index] = block;
    WriteData(disk_name,&block,chunck,len);
    UpdateSuperBlock(s, disk_name);
}

size_t FileExists(char* disk_name,char* filename,SuperBlock *s)
{
    FILE* fp;
    errno_t err = fopen_s(&fp, disk_name, "rb");
    if (err)
        return FALSE;
    fseek(fp, s->uLookup_offset, SEEK_SET);
    FileHeader* head = new FileHeader[s->uLookup_curr_size];
    fread(head,sizeof(FileHeader),s->uLookup_curr_size,fp);
    fclose(fp);

    for (size_t i = 0; i < s->uLookup_curr_size; i++)
    {
        FileHeader* f = (head + i);
        if (strstr(f->name, filename))
        {
            return i;
        }
    }
    return -1; 
}

int WriteFS(std::string disk_name,SuperBlock* s,std::string filename,char* buffer,size_t bufflen)
{
    FILE* fp;
    errno_t err = fopen_s(&fp, filename.c_str(), disk_name.c_str());
    if (err)
        return -1;
}